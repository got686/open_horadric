// Generated by open_horadric. DO NOT EDIT!

import * as interfaces from './interfaces'

export enum TestEnum {
    DEFAULT = 'DEFAULT',
}


class TestMessage__TestNestedMessage implements interfaces.TestMessage__ITestNestedMessage {
    bar: string

    public constructor (
            bar: string = '',
    ) {
        this.bar = bar
    }

    public static FromData(data: interfaces.TestMessage__ITestNestedMessageData): TestMessage__TestNestedMessage {
        if (data === undefined) {
            return new TestMessage__TestNestedMessage()
        }

        return new TestMessage__TestNestedMessage(
            data.bar,
        )
    }
}

enum TestMessage__TestNestedEnum {
    DEFAULT = 'DEFAULT',
}


export class TestMessage implements interfaces.ITestMessage {
    public static TestNestedMessage = TestMessage__TestNestedMessage
    public static TestNestedEnum = TestMessage__TestNestedEnum
    double: number
    float: number
    int64: number
    uint64: number
    int32: number
    fixed64: number
    fixed32: number
    bool: boolean
    string: string
    testNestedMessage: TestMessage__TestNestedMessage
    bytes: string
    uint32: number
    testNestedEnum: keyof typeof TestMessage__TestNestedEnum
    sfixed32: number
    sfixed64: number
    sint32: number
    sint64: number
    pbtMessageMap: { [key: number]: TestMessage__TestNestedMessage }

    public constructor (
            double: number = 0,
            float: number = 0,
            int64: number = 0,
            uint64: number = 0,
            int32: number = 0,
            fixed64: number = 0,
            fixed32: number = 0,
            bool: boolean = false,
            string: string = '',
            testNestedMessage: TestMessage__TestNestedMessage = new TestMessage__TestNestedMessage(),
            bytes: string = '',
            uint32: number = 0,
            testNestedEnum: keyof typeof TestMessage__TestNestedEnum = TestMessage__TestNestedEnum.DEFAULT,
            sfixed32: number = 0,
            sfixed64: number = 0,
            sint32: number = 0,
            sint64: number = 0,
            pbtMessageMap: { [key: number]: TestMessage__TestNestedMessage } = {},
    ) {
        this.double = double
        this.float = float
        this.int64 = int64
        this.uint64 = uint64
        this.int32 = int32
        this.fixed64 = fixed64
        this.fixed32 = fixed32
        this.bool = bool
        this.string = string
        this.testNestedMessage = testNestedMessage
        this.bytes = bytes
        this.uint32 = uint32
        this.testNestedEnum = testNestedEnum
        this.sfixed32 = sfixed32
        this.sfixed64 = sfixed64
        this.sint32 = sint32
        this.sint64 = sint64
        this.pbtMessageMap = pbtMessageMap
    }

    public static FromData(data: interfaces.ITestMessageData): TestMessage {
        if (data === undefined) {
            return new TestMessage()
        }

        const pbtMessageMap = {}
        Object.keys(data.pbtMessageMap).forEach(
            key => pbtMessageMap[key] = TestMessage__TestNestedMessage.FromData(data.pbtMessageMap[key])
        )

        return new TestMessage(
            data.double,
            data.float,
            Number(data.int64),
            Number(data.uint64),
            data.int32,
            Number(data.fixed64),
            data.fixed32,
            data.bool,
            data.string,
            data.testNestedMessage !== undefined ? TestMessage__TestNestedMessage.FromData(data.testNestedMessage) : undefined,
            data.bytes,
            data.uint32,
            data.testNestedEnum !== undefined ? TestMessage__TestNestedEnum[data.testNestedEnum] : undefined,
            data.sfixed32,
            Number(data.sfixed64),
            data.sint32,
            Number(data.sint64),
            pbtMessageMap,
        )
    }
}

